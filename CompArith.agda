module CompArith where

-- open import Data.Empty
open import Data.Fin using (Fin; zero; suc; to‚Ñï)
open import Data.Product using (‚àÉ; _√ó_; _,_; proj‚ÇÅ; proj‚ÇÇ)
open import Data.Nat
open ‚â§-Reasoning
  renaming (begin_ to start_; _‚àé to _‚ñ°; _‚â°‚ü®_‚ü©_ to _‚â°‚ü®_‚ü©'_)
open import Data.Nat.Properties
open import Data.Nat.Properties.Simple

open import Data.Integer as Int using (‚Ñ§; +_; sign; _‚äñ_) renaming (_*_ to _‚Ñ§*_; _+_ to _‚Ñ§+_; _-_ to _‚Ñ§-_; _‚â§_ to _‚Ñ§‚â§_)
open Int.‚â§-Reasoning
  renaming (begin_ to start‚Ñ§_; _‚àé to _‚Ñ§‚ñ°; _‚â°‚ü®_‚ü©_ to _‚â°‚Ñ§‚ü®_‚ü©_; _‚â§‚ü®_‚ü©_ to _‚Ñ§‚â§‚ü®_‚ü©_)
  
open import Data.Vec
open import Data.Sign using (Sign)
open import Relation.Binary.PropositionalEquality as PropEq
  using (_‚â°_; _‚â¢_; refl; sym; cong; cong‚ÇÇ)
open PropEq.‚â°-Reasoning
-- open import Relation.Nullary using (¬¨_; Dec; yes; no)

open import Algebra
import Data.Integer.Properties as IntegerProp
private
  module CR = CommutativeRing IntegerProp.commutativeRing

private
  module CS = CommutativeSemiring Data.Nat.Properties.commutativeSemiring


open import NatProps
open import IntProps

ùîπ = Fin 2

-- compl : ‚àÄ {k} -> Vec ùîπ (‚Ñï.suc k) -> Vec ùîπ (‚Ñï.suc k)
-- compl {zero} (x ‚à∑ []) = not x ‚à∑ []
-- compl {suc k} (x ‚à∑ xs) = not x ‚à∑ compl xs

Œ£ : ‚àÄ {k} -> Vec ùîπ k -> ‚Ñï
Œ£ {zero} [] = 0
Œ£ {suc i} (zero ‚à∑ xs) = Œ£ xs
Œ£ {suc i} (suc zero ‚à∑ xs) = (2 ^ i) + Œ£ xs
Œ£ {suc i} (suc (suc ()) ‚à∑ xs)


Œ£spec : ‚àÄ {k} -> Vec ùîπ k -> ‚Ñï
Œ£spec {0} [] = 0
Œ£spec {suc i} (x ‚à∑ xs) = to‚Ñï x * 2 ^ i + Œ£spec xs

Œ£spec-step : ‚àÄ {k} -> Vec ùîπ k -> ‚Ñï
Œ£spec-step  {0} [] = 0
Œ£spec-step {suc i} (x ‚à∑ xs) = to‚Ñï x * 2 ^ i + Œ£ xs


-- Œ£ is a better def. to work with ... similar to the def. of ‚ü™_‚ü´
Œ£spec‚â°Œ£ : ‚àÄ {k} (x : Vec ùîπ k) -> Œ£spec x ‚â° Œ£ x
Œ£spec‚â°Œ£ [] = refl
Œ£spec‚â°Œ£ (zero ‚à∑ xs) = Œ£spec‚â°Œ£ xs
Œ£spec‚â°Œ£ {suc i} (suc zero ‚à∑ xs) rewrite 1*m‚â°m {2 ^ i} = cong (_+_ (2 ^ i)) (Œ£spec‚â°Œ£ xs)
Œ£spec‚â°Œ£ {suc i} (suc (suc ()) ‚à∑ xs)


Œ£spec-step‚â°Œ£ : ‚àÄ {k} (x : Vec ùîπ k) -> Œ£spec-step x ‚â° Œ£ x
Œ£spec-step‚â°Œ£ [] = refl
Œ£spec-step‚â°Œ£ (zero ‚à∑ xs) = refl
Œ£spec-step‚â°Œ£ {suc i} (suc zero ‚à∑ xs) rewrite 1*m‚â°m {2 ^ i} = refl
Œ£spec-step‚â°Œ£ {suc i} (suc (suc ()) ‚à∑ xs)


‚ü¶_‚üß : ‚àÄ {k} -> Vec ùîπ (‚Ñï.suc k) -> ‚Ñï
‚ü¶ xs ‚üß = Œ£ xs


‚ü™_‚ü´ : ‚àÄ {k} -> Vec ùîπ (‚Ñï.suc k) -> ‚Ñ§
‚ü™_‚ü´ {k} (zero ‚à∑ xs) = + Œ£ xs
‚ü™_‚ü´ {k} (suc zero ‚à∑ xs) = - (2 ^ k) ‚Ñ§+ (+ Œ£ xs)
‚ü™_‚ü´ {k} (suc (suc ()) ‚à∑ xs)


œÉ : ‚àÄ {k} -> Vec ùîπ (‚Ñï.suc k) -> Sign
œÉ (zero ‚à∑ xs) = Sign.+
œÉ (suc zero ‚à∑ xs) = Sign.-
œÉ (suc (suc ()) ‚à∑ xs)


Top : ‚àÄ {k : ‚Ñï} -> Vec ùîπ k
Top {zero} = []
Top {suc k} = suc zero ‚à∑ Top

Bot : ‚àÄ {k : ‚Ñï} -> Vec ùîπ k
Bot {zero} = []
Bot {suc k} = zero ‚à∑ Bot


‚â§-Top : ‚àÄ {k} {x : Vec ùîπ k} -> Œ£ x ‚â§ Œ£ (Top {k})
‚â§-Top {zero} {[]} = z‚â§n
‚â§-Top {suc k} {zero ‚à∑ xs} = ‚â§-steps {Œ£ xs} {Œ£ {k} Top} (2 ^ k) (‚â§-Top {k})
‚â§-Top {suc k} {suc zero ‚à∑ xs} = ‚â§-steps2 (2 ^ k) (‚â§-Top {k})
‚â§-Top {suc k} {suc (suc ()) ‚à∑ xs}


Œ£Bot‚â°0 : ‚àÄ {k} -> Œ£ (Bot {k}) ‚â° 0
Œ£Bot‚â°0 {zero} = refl
Œ£Bot‚â°0 {suc k} = Œ£Bot‚â°0 {k}

Bot-‚â§ : ‚àÄ {k} {x : Vec ùîπ k} -> Œ£ (Bot {k}) ‚â§ Œ£ x
Bot-‚â§ {k} {x} rewrite Œ£Bot‚â°0 {k} = z‚â§n


lem-1-1-aux1 : ‚àÄ {k} -> Œ£ (Top {k}) ‚â° (2 ^ k) ‚à∏ 1 -- equiv to ‚ü¶ Top {k} ‚üß ‚â° (2 ^ k) ‚à∏ 1
lem-1-1-aux1 {zero} = refl
lem-1-1-aux1 {suc k} rewrite lem-1-1-aux1 {k} | +-right-identity (2 ^ k) = begin
  (2 ^ k) + ((2 ^ k) ‚à∏ 1) ‚â°‚ü® sym (+-‚à∏-assoc (2 ^ k) {2 ^ k} {1} (1‚â§2^k {k})) ‚ü© refl


lem-1-1 : ‚àÄ {k} {x : Vec ùîπ (suc k)} -> sign ‚ü™ x ‚ü´ ‚â° œÉ x
lem-1-1 {k} {zero ‚à∑ xs} = refl
lem-1-1 {k} {suc zero ‚à∑ xs} = aux‚ÇÇ (- (2 ^ k) ‚Ñ§+ + Œ£ xs) aux
  where
  aux‚ÇÅ : - (2 ^ k) ‚Ñ§+ + ((2 ^ k) ‚à∏ 1) ‚â° - 1
  aux‚ÇÅ = begin
    - (2 ^ k) ‚Ñ§+ + ((2 ^ k) ‚à∏ 1) ‚â°‚ü® cong (_‚Ñ§+_ (- (2 ^ k))) (sym (‚äñ-‚â• (1‚â§2^k {k}))) ‚ü©
    - (2 ^ k) ‚Ñ§+ ((2 ^ k) ‚äñ 1) ‚â°‚ü® cong (_‚Ñ§+_ (- (2 ^ k))) (m‚äñn‚â°m‚Ñ§-n (2 ^ k) 1) ‚ü©
    - (2 ^ k) ‚Ñ§+ (+ (2 ^ k) ‚Ñ§+ - 1) ‚â°‚ü® sym (CR.+-assoc (- (2 ^ k)) (+ (2 ^ k)) (- 1)) ‚ü©
    (- (2 ^ k) ‚Ñ§+ + (2 ^ k)) ‚Ñ§+ - 1 ‚â°‚ü® CR.+-comm (- (2 ^ k) ‚Ñ§+ + (2 ^ k)) (- 1) ‚ü©
    - 1 ‚Ñ§+ (- (2 ^ k) ‚Ñ§+ + (2 ^ k)) ‚â°‚ü® cong (_‚Ñ§+_ (- 1)) (CR.+-comm (- (2 ^ k)) (+ (2 ^ k))) ‚ü©
    - 1 ‚Ñ§+ (+ (2 ^ k) ‚Ñ§- + (2 ^ k)) ‚â°‚ü® cong (_‚Ñ§+_ (- 1)) (sym (m‚äñn‚â°m‚Ñ§-n (2 ^ k) (2 ^ k))) ‚ü©
    - 1 ‚Ñ§+ ((2 ^ k) ‚äñ (2 ^ k)) ‚â°‚ü® cong (_‚Ñ§+_ (- 1)) (IntegerProp.n‚äñn‚â°0 (2 ^ k)) ‚ü©
    - 1 ‚àé

  aux‚ÇÇ : ‚àÄ x -> x ‚Ñ§‚â§ - 1 -> sign x ‚â° Sign.-
  aux‚ÇÇ (+_ n) ()
  aux‚ÇÇ (Int.-[1+_] n) x‚â§‚Ñ§-1 = refl

  aux : ‚ü™ suc zero ‚à∑ xs ‚ü´ ‚Ñ§‚â§ - 1
  aux rewrite sym aux‚ÇÅ | sym (lem-1-1-aux1 {k}) = ‚Ñ§‚â§-steps (- (2 ^ k)) (Int.+‚â§+ (‚â§-Top {k}))

lem-1-1 {k} {suc (suc ()) ‚à∑ xs}


_modùîπ : ‚Ñï -> ùîπ
0 modùîπ = zero
1 modùîπ = suc zero
suc (suc a) modùîπ = a modùîπ

modùîπspec : ‚àÄ {a} -> to‚Ñï ( a modùîπ ) ‚â° a mod 2
modùîπspec {zero} = refl
modùîπspec {suc zero} = refl
modùîπspec {suc (suc a)} = modùîπspec {a}


_divùîπ : ‚Ñï -> ùîπ
0 divùîπ = zero
1 divùîπ = zero
suc (suc a) divùîπ = suc zero


divùîπspec : ‚àÄ {a b c : ùîπ} -> to‚Ñï ( ( (to‚Ñï a) + (to‚Ñï b) + (to‚Ñï c) ) divùîπ ) ‚â° ‚åä (to‚Ñï a) + (to‚Ñï b) + (to‚Ñï c) /2‚åã
divùîπspec {zero} {zero} {zero} = refl
divùîπspec {zero} {zero} {suc zero} = refl
divùîπspec {zero} {zero} {suc (suc ())}
divùîπspec {zero} {suc zero} {zero} = refl
divùîπspec {zero} {suc zero} {suc zero} = refl
divùîπspec {zero} {suc zero} {suc (suc ())}
divùîπspec {zero} {suc (suc ())}
divùîπspec {suc zero} {zero} {zero} = refl
divùîπspec {suc zero} {zero} {suc zero} = refl
divùîπspec {suc zero} {zero} {suc (suc ())}
divùîπspec {suc zero} {suc zero} {zero} = refl
divùîπspec {suc zero} {suc zero} {suc zero} = refl
divùîπspec {suc zero} {suc zero} {suc (suc ())}
divùîπspec {suc zero} {suc (suc ())}
divùîπspec {suc (suc ())}


-- addition

_‚äï_ : ‚àÄ {k : ‚Ñï} -> Vec ùîπ k -> Vec ùîπ k -> (Vec ùîπ k √ó ùîπ)
[] ‚äï [] = [] , zero
(a ‚à∑ xa) ‚äï (b ‚à∑ xb) =
  ( ( (to‚Ñï a) + (to‚Ñï b) + (to‚Ñï c) ) modùîπ ) ‚à∑ xa‚äïxb , ( (to‚Ñï a) + (to‚Ñï b) + (to‚Ñï c) ) divùîπ
  where
  xa‚äïxb = proj‚ÇÅ (xa ‚äï xb)
  c = proj‚ÇÇ (xa ‚äï xb)


-- _‚Üê!_ : ‚àÄ {a} {A : Set a} m {n} -> Vec A (m + suc n) -> A
-- 0 ‚Üê! (x ‚à∑ _) = x
-- (suc m) ‚Üê! (_ ‚à∑ xs) = m ‚Üê! xs


-- si+k‚â°i+sk : ‚àÄ {i k} -> suc i + k ‚â° i + suc k
-- si+k‚â°i+sk {zero} {k} = refl
-- si+k‚â°i+sk {suc i} = cong suc (si+k‚â°i+sk {i})


-- ‚àÅ : ‚àÄ {k : ‚Ñï} (i : ‚Ñï) -> Vec ùîπ (i + suc k) -> Vec ùîπ (i + suc k) -> ùîπ
-- ‚àÅ 0 a b = zero
-- ‚àÅ {k} (suc i) a b rewrite si+k‚â°i+sk {i} {suc k} = ( (to‚Ñï (i ‚Üê! a) ) + (to‚Ñï (i ‚Üê! b) ) + (to‚Ñï (‚àÅ i a b) ) ) divùîπ


-- r : ‚àÄ {k : ‚Ñï} (i : ‚Ñï) -> Vec ùîπ (i + suc k) -> Vec ùîπ (i + suc k) -> ùîπ
-- r i a b = ( (to‚Ñï (i ‚Üê! a) ) + (to‚Ñï (i ‚Üê! b) ) + (to‚Ñï (‚àÅ i a b) ) ) modùîπ

-- lem-2-2-aux1 : ‚àÄ {k : ‚Ñï} {a b : ùîπ} {xa xb : Vec ùîπ k} -> ‚ü¶ a ‚à∑ xa ‚üß + ‚ü¶ b ‚à∑ xb ‚üß ‚â° ‚ü¶ xa ‚üß + ‚ü¶ xb ‚üß + to‚Ñï a * (2 ^ k) + to‚Ñï b * (2 ^ k)
-- lem-2-2-aux1 = ?


lem-2-2-aux1 : ‚àÄ {a b c : ùîπ} -> to‚Ñï a + to‚Ñï b + to‚Ñï c ‚â° to‚Ñï ((to‚Ñï a + to‚Ñï b + to‚Ñï c) divùîπ) * 2 + to‚Ñï ((to‚Ñï a + to‚Ñï b + to‚Ñï c) modùîπ)
lem-2-2-aux1 {zero} {zero} {zero} = refl
lem-2-2-aux1 {zero} {zero} {suc zero} = refl
lem-2-2-aux1 {zero} {zero} {suc (suc ())}
lem-2-2-aux1 {zero} {suc zero} {zero} = refl
lem-2-2-aux1 {zero} {suc zero} {suc zero} = refl
lem-2-2-aux1 {zero} {suc zero} {suc (suc ())}
lem-2-2-aux1 {zero} {suc (suc ())}
lem-2-2-aux1 {suc zero} {zero} {zero} = refl
lem-2-2-aux1 {suc zero} {zero} {suc zero} = refl
lem-2-2-aux1 {suc zero} {zero} {suc (suc ())}
lem-2-2-aux1 {suc zero} {suc zero} {zero} = refl
lem-2-2-aux1 {suc zero} {suc zero} {suc zero} = refl
lem-2-2-aux1 {suc zero} {suc zero} {suc (suc ())}
lem-2-2-aux1 {suc zero} {suc (suc ())}
lem-2-2-aux1 {suc (suc ())}


lem-2-2 : ‚àÄ {k : ‚Ñï} {a b : Vec ùîπ (suc k)} -> ‚ü¶ a ‚üß + ‚ü¶ b ‚üß ‚â° ‚ü¶ proj‚ÇÇ (a ‚äï b) ‚à∑ proj‚ÇÅ (a ‚äï b) ‚üß
lem-2-2 {zero} {zero ‚à∑ []} {zero ‚à∑ []} = refl
lem-2-2 {zero} {zero ‚à∑ []} {suc zero ‚à∑ []} = refl
lem-2-2 {zero} {zero ‚à∑ []} {suc (suc ()) ‚à∑ []}
lem-2-2 {zero} {suc zero ‚à∑ []} {zero ‚à∑ []} = refl
lem-2-2 {zero} {suc zero ‚à∑ []} {suc zero ‚à∑ []} = refl
lem-2-2 {zero} {suc zero ‚à∑ []} {suc (suc ()) ‚à∑ []}
lem-2-2 {zero} {suc (suc ()) ‚à∑ []} {b ‚à∑ []}
lem-2-2 {suc k} {a ‚à∑ xa} {b ‚à∑ xb} rewrite
  sym (Œ£spec-step‚â°Œ£ {suc (suc k)} (a ‚à∑ xa)) | sym (Œ£spec-step‚â°Œ£ {suc (suc k)} (b ‚à∑ xb)) |
  sym (Œ£spec-step‚â°Œ£ {suc (suc (suc k))} (((to‚Ñï a + to‚Ñï b + to‚Ñï (proj‚ÇÇ (xa ‚äï xb))) divùîπ) ‚à∑ ((to‚Ñï a + to‚Ñï b + to‚Ñï (proj‚ÇÇ (xa ‚äï xb))) modùîπ) ‚à∑ proj‚ÇÅ (xa ‚äï xb))) |
  sym (Œ£spec-step‚â°Œ£ {suc (suc k)} (((to‚Ñï a + to‚Ñï b + to‚Ñï (proj‚ÇÇ (xa ‚äï xb))) modùîπ) ‚à∑ proj‚ÇÅ (xa ‚äï xb))) |
  m+0‚â°m {2 ^ k} | m+0‚â°m {(2 ^ k) + (2 ^ k)} = begin
    to‚Ñï a * ((2 ^ k) + (2 ^ k)) + ‚ü¶ xa ‚üß + (to‚Ñï b * ((2 ^ k) + (2 ^ k)) + ‚ü¶ xb ‚üß) ‚â°‚ü® a+b+c+d‚â°a+c+b+d {to‚Ñï a * ((2 ^ k) + (2 ^ k))} ‚ü©
    to‚Ñï a * ((2 ^ k) + (2 ^ k)) + to‚Ñï b * ((2 ^ k) + (2 ^ k)) + (‚ü¶ xa ‚üß + ‚ü¶ xb ‚üß) ‚â°‚ü® cong (_+_ (to‚Ñï a * ((2 ^ k) + (2 ^ k)) + to‚Ñï b * ((2 ^ k) + (2 ^ k)))) ih ‚ü©
    to‚Ñï a * ((2 ^ k) + (2 ^ k)) + to‚Ñï b * ((2 ^ k) + (2 ^ k)) + (to‚Ñï (proj‚ÇÇ (xa ‚äï xb)) * ((2 ^ k) + (2 ^ k)) + ‚ü¶ proj‚ÇÅ (xa ‚äï xb) ‚üß)
      ‚â°‚ü® sym (CS.+-assoc (to‚Ñï a * ((2 ^ k) + (2 ^ k)) + to‚Ñï b * ((2 ^ k) + (2 ^ k))) (to‚Ñï (proj‚ÇÇ (xa ‚äï xb)) * ((2 ^ k) + (2 ^ k))) ‚ü¶ proj‚ÇÅ (xa ‚äï xb) ‚üß) ‚ü©
    to‚Ñï a * ((2 ^ k) + (2 ^ k)) + to‚Ñï b * ((2 ^ k) + (2 ^ k)) + to‚Ñï (proj‚ÇÇ (xa ‚äï xb)) * ((2 ^ k) + (2 ^ k)) + ‚ü¶ proj‚ÇÅ (xa ‚äï xb) ‚üß ‚â°‚ü® a*x+b*x+c*x+d‚â°x*a+b+c+d {(2 ^ k) + (2 ^ k)} {to‚Ñï a} {to‚Ñï b} ‚ü©
    ((2 ^ k) + (2 ^ k)) * ( to‚Ñï a + to‚Ñï b + to‚Ñï (proj‚ÇÇ (xa ‚äï xb)) ) + ‚ü¶ proj‚ÇÅ (xa ‚äï xb) ‚üß
      ‚â°‚ü® m+n‚â°m'+n' {((2 ^ k) + (2 ^ k)) * ( to‚Ñï a + to‚Ñï b + to‚Ñï (proj‚ÇÇ (xa ‚äï xb)) )} {m' = ((2 ^ k) + (2 ^ k)) * ( to‚Ñï ((to‚Ñï a + to‚Ñï b + to‚Ñï (proj‚ÇÇ (xa ‚äï xb))) divùîπ) * 2 + to‚Ñï ((to‚Ñï a + to‚Ñï b + to‚Ñï (proj‚ÇÇ (xa ‚äï xb))) modùîπ) )}
        (cong (_*_ ((2 ^ k) + (2 ^ k))) (lem-2-2-aux1 {a} {b} {proj‚ÇÇ (xa ‚äï xb)}))
        refl ‚ü©
    ((2 ^ k) + (2 ^ k)) * ( to‚Ñï ((to‚Ñï a + to‚Ñï b + to‚Ñï (proj‚ÇÇ (xa ‚äï xb))) divùîπ) * 2 + to‚Ñï ((to‚Ñï a + to‚Ñï b + to‚Ñï (proj‚ÇÇ (xa ‚äï xb))) modùîπ) ) + ‚ü¶ proj‚ÇÅ (xa ‚äï xb) ‚üß
      ‚â°‚ü® x*a*x+b+c‚â°a*x+b*x+x+c {(2 ^ k) + (2 ^ k)} {to‚Ñï ((to‚Ñï a + to‚Ñï b + to‚Ñï (proj‚ÇÇ (xa ‚äï xb))) divùîπ)} ‚ü©
    to‚Ñï ((to‚Ñï a + to‚Ñï b + to‚Ñï (proj‚ÇÇ (xa ‚äï xb))) divùîπ) * ((2 ^ k) + (2 ^ k) + ((2 ^ k) + (2 ^ k))) + to‚Ñï ((to‚Ñï a + to‚Ñï b + to‚Ñï (proj‚ÇÇ (xa ‚äï xb))) modùîπ) * ((2 ^ k) + (2 ^ k)) + ‚ü¶ proj‚ÇÅ (xa ‚äï xb) ‚üß
      ‚â°‚ü® CS.+-assoc (to‚Ñï ((to‚Ñï a + to‚Ñï b + to‚Ñï (proj‚ÇÇ (xa ‚äï xb))) divùîπ) * ((2 ^ k) + (2 ^ k) + ((2 ^ k) + (2 ^ k)))) (to‚Ñï ((to‚Ñï a + to‚Ñï b + to‚Ñï (proj‚ÇÇ (xa ‚äï xb))) modùîπ) * ((2 ^ k) + (2 ^ k))) ‚ü¶ proj‚ÇÅ (xa ‚äï xb) ‚üß ‚ü©
    to‚Ñï ((to‚Ñï a + to‚Ñï b + to‚Ñï (proj‚ÇÇ (xa ‚äï xb))) divùîπ) * ((2 ^ k) + (2 ^ k) + ((2 ^ k) + (2 ^ k))) + (to‚Ñï ((to‚Ñï a + to‚Ñï b + to‚Ñï (proj‚ÇÇ (xa ‚äï xb))) modùîπ) * ((2 ^ k) + (2 ^ k)) + ‚ü¶ proj‚ÇÅ (xa ‚äï xb) ‚üß)  ‚àé
  where
  ih : ‚ü¶ xa ‚üß + ‚ü¶ xb ‚üß ‚â° to‚Ñï (proj‚ÇÇ (xa ‚äï xb)) * ((2 ^ k) + (2 ^ k)) + ‚ü¶ proj‚ÇÅ (xa ‚äï xb) ‚üß
  ih rewrite 2^k+2^k‚â°2^sk {k} | Œ£spec-step‚â°Œ£ {suc (suc k)} (proj‚ÇÇ (xa ‚äï xb) ‚à∑ proj‚ÇÅ (xa ‚äï xb))= lem-2-2 {k} {xa} {xb}

  a+b+c+d‚â°a+c+b+d : ‚àÄ {a b c d : ‚Ñï} -> a + b + (c + d) ‚â° a + c + (b + d)
  a+b+c+d‚â°a+c+b+d {a} {b} {c} {d} = solve 4 (Œª a b c d -> a :+ b :+ (c :+ d) := a :+ c :+ (b :+ d)) refl a b c d
    where
    open Data.Nat.Properties.SemiringSolver

  a*x+b*x+c*x+d‚â°x*a+b+c+d : ‚àÄ {x a b c d : ‚Ñï} -> a * x + b * x + c * x + d ‚â° x * (a + b + c) + d
  a*x+b*x+c*x+d‚â°x*a+b+c+d {x} {a} {b} {c} {d} = solve 5 (Œª x a b c d -> a :* x :+ b :* x :+ c :* x :+ d := x :* (a :+ b :+ c) :+ d) refl x a b c d
    where
    open Data.Nat.Properties.SemiringSolver

  x*a*x+b+c‚â°a*x+b*x+x+c : ‚àÄ {x a b c : ‚Ñï} -> x * (a * 2 + b) + c ‚â° a * (x + x) + b * x + c
  x*a*x+b+c‚â°a*x+b*x+x+c {x} {a} {b} {c} = solve 4 (Œª x a b c -> x :* (a :* con 2 :+ b) :+ c := a :* (x :+ x) :+ b :* x :+ c) refl x a b c
    where
    open Data.Nat.Properties.SemiringSolver


-- lemma 2.4

‚ü™Top‚ü´ : ‚àÄ {k : ‚Ñï} -> Vec ùîπ k
‚ü™Top‚ü´ {zero} = []
‚ü™Top‚ü´ {suc k} = zero ‚à∑ Top


‚ü™Bot‚ü´ : ‚àÄ {k : ‚Ñï} -> Vec ùîπ k
‚ü™Bot‚ü´ {zero} = []
‚ü™Bot‚ü´ {suc k} = suc zero ‚à∑ Bot



‚â§-‚ü™Top‚ü´ : ‚àÄ {k} {x : Vec ùîπ (suc k)} -> ‚ü™ x ‚ü´ ‚Ñ§‚â§ ‚ü™ ‚ü™Top‚ü´ {suc k} ‚ü´
‚â§-‚ü™Top‚ü´ {k} {zero ‚à∑ xs} = Int.+‚â§+ (‚â§-Top {k})
‚â§-‚ü™Top‚ü´ {k} {suc zero ‚à∑ xs} = start‚Ñ§
  (- (2 ^ k)) ‚Ñ§+ + Œ£ xs ‚Ñ§‚â§‚ü® ‚Ñ§‚â§-steps (- (2 ^ k)) ( Int.+‚â§+ (‚â§-Top {k}) ) ‚ü©
  (- (2 ^ k)) ‚Ñ§+ + Œ£ (Top {k}) ‚Ñ§‚â§‚ü® -k+m‚Ñ§‚â§m (2 ^ k) ‚ü©
  ‚ü™ ‚ü™Top‚ü´ {suc k} ‚ü´ ‚Ñ§‚ñ°
‚â§-‚ü™Top‚ü´ {k} {suc (suc ()) ‚à∑ xs}


‚ü™Bot‚ü´-‚â§ : ‚àÄ {k} {x : Vec ùîπ (suc k)} -> ‚ü™ ‚ü™Bot‚ü´ {suc k} ‚ü´ ‚Ñ§‚â§ ‚ü™ x ‚ü´
‚ü™Bot‚ü´-‚â§ {k} {zero ‚à∑ xs} rewrite Œ£Bot‚â°0 {k} | CR.+-comm (- (2 ^ k)) (+ 0) | (proj‚ÇÅ CR.+-identity) (- (2 ^ k)) = start‚Ñ§
  - (2 ^ k) ‚Ñ§‚â§‚ü® -‚â§0 (2 ^ k) ‚ü© + 0 ‚Ñ§‚â§‚ü® Int.+‚â§+ z‚â§n ‚ü© + Œ£ xs ‚Ñ§‚ñ° 
‚ü™Bot‚ü´-‚â§ {k} {suc zero ‚à∑ xs} rewrite Œ£Bot‚â°0 {k} = ‚Ñ§‚â§-steps (- (2 ^ k)) (Int.+‚â§+ z‚â§n)
‚ü™Bot‚ü´-‚â§ {x = suc (suc ()) ‚à∑ xs}
